# OYM Indoor SDK for iOS

##Preparing environmentThe Base SDK version used in the project shall be iOS7. It is also required to add the `â€“ObjC` flag under the Linking section in the Building Settings.
In order to be able to communicate with the server, it is required to include the Links framework to the project.  The Routing bundle is required to provide a basic icons and strings for the routing. 
This framework can work with most of the Maps API available. It is possible to use Google Maps by defining a macro called `INDOOR_HASGOOGLEMAP` before using the framework. In this case, it is required to add all the Google Maps for iOS frameworks [+info](https://developers.google.com/maps/documentation/ios/).## Preparing a sample appIn order to use the indoor framework, a basic iOS app shall be created. After making all the modifications mentioned in the previous section, it is necessary to bear in mind that the application is using the Bluetooth and WiFi/Network connection; hence it is necessary to check that all this features are available.The next step is to define a delegate class that conforms to the `OYMIndoorLocationDelegate` protocol. This delegate will be called each time a position is computed. It also provides information whether the Location provider have been started properly.```objectivec/** *  This delegate will provide feedback to the user regarding the indoor location library. */@protocol OYMIndoorLocationDelegate <NSObject>@required/** *  This method is called when the indoor location service has been * correctly started. */- (void) didStartSuccessfully;/** *  This method is called when an exception is thrown when trying to * start the indoor location service. */- (void) didFailStarting;/** *  This method is called when a new position is available. * * @param location User position */- (void) onPositionUpdate:(OYMIndoorLocation*)location;/** *  This method is callen when a notification is triggered. * * @param notification Notification triggered */- (void) onNotification:(OYMNotificationResult*)notification;@optional/** *  This method is called when the app has not the right authorisation for the Location Services. * * @param current Current Authorisation Permission */- (void) locationAlwaysAuthorizationRequired:(CLAuthorizationStatus)current;/** *  This method is called when the Location Services are disabled. */- (void) locationServicesAreDisabled;@end
```The `OYMIndoorLocation` object includes the following fields:```objectivec/** WGS84 Longitude */@property (readonly) double longitude;/** WGS84 Latitude */@property (readonly) double latitude;/** Number of iBeacons used */@property (readonly) int used;/** Position accuracy (meters) */@property (readonly) double accuracy;/** List including the longitude, latitude and accuracy of each iBeacon in sight */@property (readonly) NSArray* found;/** Floor number */@property (readonly) int floornumber;/** Positioning type: kOYMIndoorLocationTypeNo, kOYMIndoorLocationTypeIbeacon, kOYMIndoorLocationTypeGps */@property (readonly) int type;/** Building name */@property (readonly) NSString* bName;/** Building ID */@property (readonly) NSString* buildingId;/** Number of geofences */@property (readonly) int geofences;```
The following step is to create a new instance of the indoor location library:```objectiveclib = [[OYMIndoorLocationLib alloc] initWithUrl:kOYMIndoorNavigationUrl andUser:user andPassword:password withDelegate:self];```
The final step to start the library. To do that we use the `startLocate` method. If the update rate is not specified, `kOYMIndoorLocationCoreDefaultRefresh` value from the framework will be assumed.```objectivec[lib startLocate];```
After starting the library, the delegate will be used when a new position is computed.### Exiting the appIn order to stop properly the library, it is necessary to call the stopLocate method when the library is no longer needed and the location service should be stopped```objectivec[lib stopLocate];```

## Creating a routeIn order to create a route, an instance of `OYMRouting` needs to be created and initialized. The constructor requires an `OYMIndoorRouting` object that has been initialized, the building ID where the routing needs to be computed and a delegate that conforms to the `OYMIndoorDelegate` protocol. Then the object needs to be initialized using the `initRouting` method. The delegate will be informed whether the init process was successful in the `didRoutingSucceed` method.

```objectivecOYMRouting* routing = [[OYMRouting alloc] initWithIndoor:indoor         andBuilding:building.uuid andDelegate:delegate];[routing initRouting];```
Once the routing object has been successfully initialized, a route between two points can be computed. For that, the position of the start and end points need to be encoded inside a `OYMRoutePoint` object.

```objectivecOYMRoute* route = [routing computeRouteFrom:start to:destination];```
### Projecting position to the routeOnce a route is computed, it is possible to project the user position to the computed route by using the `getProjectionForLocation:(OYMIndoorLocation*)` method inside the `OYMRouting` object. This method will provide a `OYMRoutingResult` that will provide the user position on top of the route, a flag telling whether the user is too far away from the route and further useful information.## Showing indoor maps In order to show the indoor maps overlap in MapKit framework, the framework include a helper class `OYMTileOverlay` that inherits from `MKTileOverlay`. This object can be retrieved from the `OYMFloor` class and overlay it on a `MKMapView` instance.```objectivectileOverlay = f.tileProvider;[mapView addOverlay:tileOverlay level:MKOverlayLevelAboveLabels];```
The first step is to retrieve the buildings from the server. In order to do that we use the `OYMIndoor` class. The following constructor shall be used. In there the webservices Url, username, password and delegate shall be provided. The `OYMIndoorDelegate` will handle the communication with the server.```objectivecindoor = [[OYMIndoor alloc] initWithUrl:kOYMIndoorNavigationUrl andUser:user andPassword:password andDelegate:self];```
When the connection is established successfully, the next step is to retrieve the buildings from the server. For that, with the Indoor object we created, we use the getBuildings methods. There are simplified versions reducing input parameters of this method, which might apply for certain cases.```objectivec- (void) getBuildingsWithArray:(NSArray*)buildingIdList andBoundingBox:(NSString*)boundingBox andOffset:(int)offset andBucketSize:(int)bucketSize;```
In there we specify a list of buildingId to be retrieved, the bounding box in which the search shall be performed, an offset for the results and the max size of the result. The result of the request will be handled by the `OYMIndoor` delegate. ```objectivec/** *  This delegate is called when the get buildings process is finished. * * @param buildings Array containing the requested buildings, <tt>nil</tt> if no buildings * @param succeed Flag indicating if the process was successfull. */- (void) didGetBuildings:(NSArray*)buildings succeeded:(BOOL)succeed;```

When the building list has been successfully retrieved, all the information needed is already retrieved. In each Building object, it includes all the floors available for that building, including their tile providers. In order to access an OYMTileProvider we just need to use the `tileProvider` property:```objectivecOYMBuilding* building = [buildings objectAtIndex:iBuilding];NSArray* floors = [building getFloorsList];OYMFloor* floor = [floors objectAtIndex:iFloor];OYMTileOverlay* tiles = floor.tileProvider;```
Finally, this `OYMTileOverlay` can be directly added to the map. ```objectivec[mapView addOverlay:tiles level:MKOverlayLevelAboveLabels];```
### Exiting the appBefore exiting the app it is advisable to disconnect from the server. For that, the stopLocate method shall be called.```objectivec[lib stopLocate];
```